## 单一职责(SRP)
#### 单一职责原则的英文名称是Single Responsibility Principle，简称是SRP
#### 单一职责原则的定义是：应该有且仅有一个原因引起类的变更。
#### 单一职责原则有什么好处：
● 类的复杂性降低，实现什么职责都有清晰明确的定义；

● 可读性提高，复杂性降低，那当然可读性提高了；

● 可维护性提高，可读性提高，那当然更容易维护了；

● 变更引起的风险降低

## 里氏替换原则（LSP）
#### 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。
#### 所有引用基类的地方必须能透明地使用其子类的对象。
#### 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

## 依赖倒置原则（Dependence Inversion Principle,DIP）
● 高层模块不应该依赖低层模块，两者都应该依赖其抽象；

● 抽象不应该依赖细节；

● 细节应该依赖抽象。

#### 具体体现：
● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；

● 接口或抽象类不依赖于实现类；

● 实现类依赖接口或抽象类。

#### 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。
#### 依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合
#### 在项目中使用这个规则呢？只要遵循以下的几个规则:
● 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备

● 变量的表面类型尽量是接口或者是抽象类

● 任何类都不应该从具体类派生

● 尽量不要覆写基类的方法

● 结合里氏替换原则使用

## 接口隔离原则
● Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口。）

● The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）
综上所述总结：建立单一接口，不要建立臃肿庞大的接口

#### 接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。
#### 接口隔离原则是对接口进行规范约束
● 接口要尽量小（根据接口隔离原则拆分接口时，首先必须满足单一职责原则。）

● 接口要高内聚（要求在接口中尽量少公布public方法）

● 定制服务

● 接口设计是有限度的

#### 原子划分原则：
● 一个接口只服务于一个子模块或业务逻辑；

● 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；

● 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；

● 了解环境，拒绝盲从。

## 迪米特法则（LoD）也称为最少知识原则（LKP）
#### 一个对象应该对其他对象有最少的了解。
    一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部
    是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多
    public方法，我就调用这么多，其他的我一概不关心。

#### 只和朋友交流（两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等）

``` 朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，```

#### 朋友间也是有距离的(一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。)
#### 是自己的就是自己的(如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。)
#### 谨慎使用Serializable

## 开闭原则
#### 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。（其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。）


